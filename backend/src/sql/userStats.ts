// Generated by sqltyper 1.0.1 from userStats.sql.
// Do not edit directly. Instead, edit userStats.sql and re-run sqltyper.

import { ClientBase, Pool } from 'pg'

export async function userStats(
  client: ClientBase | Pool,
  params: { limit: number }
): Promise<
  Array<{
    month: string
    user_id: number
    user_name: string
    win_count: number
    overtime_win_count: number
    goals_for: number
  }>
> {
  const result = await client.query(
    `\
WITH result AS (
    SELECT
        finished_time,
        home_user_id AS user_id,
        home_score AS goals_for,
        finished_type <> 'penalties' AND home_score > away_score AS win,
        finished_type = 'overTime' AND home_score > away_score AS overtime_win
    FROM match
    WHERE
        finished_type IS NOT NULL AND
        finished_time IS NOT NULL AND
        home_score IS NOT NULL AND
        away_score IS NOT NULL
    UNION ALL
    SELECT
        finished_time,
        away_user_id AS user_id,
        away_score AS goals_for,
        finished_type <> 'penalties' AND away_score > home_score AS win,
        finished_type = 'overTime' AND away_score > home_score AS overtime_win
    FROM match
    WHERE
        finished_type IS NOT NULL AND
        finished_time IS NOT NULL AND
        home_score IS NOT NULL AND
        away_score IS NOT NULL
    ORDER BY finished_time DESC
    LIMIT CASE
        WHEN $1 = 0 THEN NULL
        ELSE $1 * 2
    END
)
SELECT
    CASE
        WHEN $1 = 0
        THEN to_char(result.finished_time, 'YYYY-MM')
        ELSE 'Last ' || $1
    END AS month,
    "user".id AS user_id,
    "user".name AS user_name,
    sum(result.win::integer)::integer as win_count,
    sum(result.overtime_win::integer)::integer as overtime_win_count,
    sum(result.goals_for::integer)::integer as goals_for
FROM "user"
JOIN result ON (result.user_id = "user".id)
GROUP BY month, "user".id, "user".name
ORDER BY month DESC, win_count ASC
`,
    [params.limit]
  )
  return result.rows
}
